// SPDX-License-Identifier: MIT 
pragma solidity >=0.8.0;

// NOTE: This file is autogenerated via `mud codegen-libdeploy` from `deploy.json`. Do not edit manually.
// NOTE: It uses relative imports. Do not move this file, instead do `mud codegen-libdeploy --out new/path`.
// (`src` for relative paths is taken from the output of `forge config`, which in turn uses `foundry.toml`)

// Foundry
import { DSTest } from "ds-test/test.sol";
import { console } from "forge-std/console.sol";

// Solecs
import { IWorld } from "solecs/interfaces/IWorld.sol";
import { World } from "solecs/World.sol";
import { IComponent } from "solecs/interfaces/IComponent.sol";
import { getAddressById } from "solecs/utils.sol";
import { IUint256Component } from "solecs/interfaces/IUint256Component.sol";
import { ISystem } from "solecs/interfaces/ISystem.sol";
import { IOwnableWritable } from "solecs/interfaces/IOwnableWritable.sol";

// Components
<% components.forEach(component => { -%>
import { <%= component %>, ID as <%= component %>ID } from "<%- nameToPath[component] %>";
<% }); -%>

// Systems
<% // (subsystems may be used for writeAccess only, so `allWritables` must be checked for missing system names)
const allSystemNames = [...new Set([
  ...systems.map(({name}) => name),
  ...allWritables.filter(({registry}) => registry === 'systems').map(({name}) => name)
])];
-%>
<% allSystemNames.forEach(name => { -%>
import { <%= name %>, ID as <%= name %>ID } from "<%- nameToPath[name] %>";
<% }); -%>

struct DeployResult {
  IWorld world;
  address deployer;
}

library LibDeploy {
  function deploy(
    address _deployer,
    address _world,
    bool _reuseComponents
  ) internal returns (DeployResult memory result) {
    result.deployer = _deployer;

    // ------------------------
    // Deploy 
    // ------------------------

    // Deploy world
    result.world = _world == address(0) ? new World() : IWorld(_world);
    if (_world == address(0)) result.world.init(); // Init if it's a fresh world

    // Deploy components
    if (!_reuseComponents) {
      IComponent comp;
<% components.forEach(component => { -%>

      console.log("Deploying <%= component %>");
      comp = new <%= component %>(address(result.world));
      console.log(address(comp));
<% }); -%>
    } 
    
    // Deploy systems 
    deploySystems(address(result.world), true);
  }
  
  /**
   * `registry` and `writableId` may stand for either components or subsystems.
   * `writer` is always a system.
   * (subsystems may be both writables and writers, since they are just systems that inherit `IOwnableWritable`)
   */
  function authorizeWriter(
    IUint256Component registry,
    uint256 writableId,
    address writer
  ) internal {
    IOwnableWritable(getAddressById(registry, writableId)).authorizeWriter(writer);
  }
  
  /**
   * Deploy systems to the given world.
   * If `init` flag is set, systems with `initialize` setting in `deploy.json` will be executed.
   */
  function deploySystems(
    address _world,
    bool init
  ) internal {
    IWorld world = IWorld(_world);
    IUint256Component components = world.components();
    IUint256Component systems = world.systems();

    // Deploy systems
    ISystem system;
<% systems.forEach(system => { -%>

    console.log("Deploying <%= system.name %>");
    system = new <%= system.name %>(world, address(components));
    world.registerSystem(address(system), <%= system.name %>ID);
    console.log(address(system));
<% }); -%>

    // Initialize systems
<% systems.forEach(system => { -%>
    system = ISystem(getAddressById(systems, <%= system.name %>ID));
<% system.writeAccess?.forEach(namePattern => { -%>
<% const writables = allWritables.filter(({name}) => namePattern === "*" || namePattern === name); -%>
<% writables.forEach((writable) => { -%>
    authorizeWriter(<%= writable.registry %>, <%= writable.name %>ID, address(system));
<% }); -%>
<% }); -%>
<% if (system.initialize) { -%>
    if(init) system.execute(<%= system.initialize -%>);
<% } -%>

<% }); -%>
  }
}
